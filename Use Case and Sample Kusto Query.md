
This tool proposes to provide details of MySQL native status data that you can used to monitor for availability and performance. 

Apart from built-in Metrics described at [Monitor Azure Database for MySQL](https://learn.microsoft.com/en-us/azure/mysql/flexible-server/concepts-monitoring), this article describes the monitoring data generated by Azure MySQL replying on MySQL native information_schema. The data collected from your Azure MySQL Database can be monitored by [Azure Monitor](https://learn.microsoft.com/en-us/azure/azure-monitor/overview). If you are unfamiliar with the features of Azure Monitor common to all Azure services that use it, read [Monitoring Azure resources with Azure Monitor](https://learn.microsoft.com/en-us/azure/azure-monitor/essentials/monitor-azure-resource).

## Data Monitoring and Collection
This tool will collect MySQL Global Status data that is logged in *information_schema.global_status* table. The detailed status defintion can be referred at [MySQL community document](https://dev.mysql.com/doc/refman/8.0/en/server-status-variables.html).

The data will be collected every 30 seconds and stored in Azure Log Analytics. User can query the data using [KQL](https://learn.microsoft.com/en-us/azure/data-explorer/kusto/query/tutorial?source=recommendations&pivots=azuredataexplorer) based on preference of needed status in a more flexible way to meet different monitoring needs.

## Analyzing Data
All data collected can be viewed and queried in [Azure Log Analytics Workspace](https://learn.microsoft.com/en-us/azure/azure-monitor/logs/log-analytics-overview).
Following demostrated some common used scenarios that user can use to monitor the MySQL database.

### Understand the query pattern of DML
DML is short name of Data Manipulation Language which deals with data manipulation and includes most common SQL statements such SELECT, INSERT, UPDATE, DELETE, etc., and it is used to store, modify, retrieve, delete and update data in a database.
These are most common queries that being frequently executed in a database. It is important to understand the query pattern of DML to monitor the database performance and availability.
> Note: This is already built-in for MYSQL Flexible Server. You can refer to [Monitor Azure Database for MySQL](https://docs.microsoft.com/en-us/azure/mysql/flexible-server/concepts-monitoring) for more details.

Below KQL summarizes the query pattern of DML in a database. It will show the total number of DML queries executed in the given time window, and the max execution count of each type of DML query. 

User can monitor the trend of DML query execution count and the max execution count of each type of DML query to understand the query pattern of DML. This would be useful when analyzing resource usage like CPU consumption.
````kql
//////////////////////////////
//  MySQL DML
/////////////////////////////
AzMyStatus_CL
| where Time_t >= ago(1h)
| where LogicalServerName_s =~ "{replace to your server name here}"
| where MetricName_s in (
    'QUERIES',
    'COM_DELETE', 
    'COM_DELETE_MULTI', 
    'COM_INSERT', 
    'COM_INSERT_SELECT', 
    'COM_SELECT', 
    'COM_UPDATE', 
    'COM_UPDATE_MULTI')         
| project Time_t, MetricName_s, MetricValue_s
| extend Queries_tmp = iff(MetricName_s == 'QUERIES', toreal(MetricValue_s), 0.0),
            Com_delete_tmp = iff(MetricName_s == 'COM_DELETE', toreal(MetricValue_s), 0.0),
            Com_delete_multi_tmp = iff(MetricName_s == 'COM_DELETE_MULTI', toreal(MetricValue_s), 0.0),
            Com_insert_tmp = iff(MetricName_s == 'COM_INSERT', toreal(MetricValue_s), 0.0),
            Com_insert_select_tmp = iff(MetricName_s == 'COM_INSERT_SELECT', toreal(MetricValue_s), 0.0),
            Com_select_tmp = iff(MetricName_s == 'COM_SELECT', toreal(MetricValue_s), 0.0),
            Com_update_tmp = iff(MetricName_s == 'COM_UPDATE', toreal(MetricValue_s), 0.0),
            Com_update_multi_tmp = iff(MetricName_s == 'COM_UPDATE_MULTI', toreal(MetricValue_s), 0.0)
| summarize Queries = max(Queries_tmp),
            Com_delete = max(Com_delete_tmp),
            Com_delete_multi = max(Com_delete_multi_tmp),
            Com_insert = max(Com_insert_tmp),
            Com_insert_select = max(Com_insert_select_tmp),
            Com_select = max(Com_select_tmp),
            Com_update = max(Com_update_tmp),
            Com_update_multi = max(Com_update_multi_tmp)
            by Time_t
| order by Time_t asc
| render timechart
````
Applying the same idea, user can modify the above KQL to monitor the query pattern of DDL, which could be used to analyze performance issues related to lockings or replication latency.

### Understand the workload of detaild IO

````kql
//////////////////////////////
//  MySQL IO request
/////////////////////////////
AzMyStatus_CL
| where Time_t >= ago(1h)
| where LogicalServerName_s =~ "{replace to your server name here}"
| where  MetricName_s  in (
    'BINLOG_IO_READ', 
    'BINLOG_IO_WRITTEN', 
    'BINLOG_DATA_READ', 
    'BINLOG_DATA_READS',
    'INNODB_DATA_READS',
    'INNODB_DATA_READ', 
    'INNODB_DATA_WRITTEN', 
    'INNODB_DATA_WRITES', 
    'INNODB_LOG_WRITES', 
    'INNODB_LOG_WRITTEN')
| extend Binlog_io_read_tmp = iff(MetricName_s =~ 'BINLOG_IO_READ', toreal(MetricValue_s), 0.0),
         Binlog_io_written_tmp = iff(MetricName_s =~ 'BINLOG_IO_WRITTEN', toreal(MetricValue_s), 0.0),
         Innodb_data_read_tmp = iff(MetricName_s =~ 'INNODB_DATA_READ', toreal(MetricValue_s), 0.0),
         Innodb_data_reads_tmp = iff(MetricName_s =~ 'INNODB_DATA_READS', toreal(MetricValue_s), 0.0),
         Innodb_data_writes_tmp = iff(MetricName_s =~ 'INNODB_DATA_WRITES', toreal(MetricValue_s), 0.0),
         Innodb_data_written_tmp = iff(MetricName_s =~ 'INNODB_DATA_WRITTEN', toreal(MetricValue_s), 0.0),
         Innodb_log_writes_tmp = iff(MetricName_s =~ 'INNODB_LOG_WRITES', toreal(MetricValue_s), 0.0),
         Innodb_log_written_tmp = iff(MetricName_s =~ 'INNODB_LOG_WRITTEN', toreal(MetricValue_s), 0.0)
| summarize Binlog_io_read_in_MB = max(Binlog_io_read_tmp)/1024/1024,
            Binlog_io_written_in_MB = max(Binlog_io_written_tmp)/1024/1024,
            Innodb_data_read_in_MB = max(Innodb_data_read_tmp)/1024/1024,
            Innodb_data_reads = max(Innodb_data_reads_tmp),
            Innodb_data_writes = max(Innodb_data_writes_tmp),
            Innodb_data_written_in_MB = max(Innodb_data_written_tmp)/1024/1024,
            Innodb_log_writes = max(Innodb_log_writes_tmp),
            Innodb_log_written_in_MB = max(Innodb_log_written_tmp)/1024/1024
            by Time_t
| order by Time_t asc
| render timechart
````


### Understand the usage of temp files
With a read-heavy workload (in most cases), queries executing against your MySQL could exceed the in-memory temporary table sizes, especalling application implemeted with some PHP-based framework like Workpress, Magento, etc. This will cause your server to switch to writing temporary tables to disk, thus affecting the performance for your WordPress instance. 
 
To determine if your server is writing to disk as a result of exceeding temporary table size, look at the following metrics: 
````sql
show global status like 'created_tmp_disk_tables'; 
show global status like 'created_tmp_tables'; 
````
The *created_tmp_disk_tables* metric indicates how many tables were created on disk, while the *created_tmp_table* metric tells you how many temporary tables have to be formed in memory given your workload. 

To determine if running a specific query will use temporary tables, run explain on the query. The detail in the 'extra' column indicates 'Using temporary' if the query will run using temporary tables. 

To calculate the percentage of your workload with queries spilling to disks, use your metric values in the formula below: 
````txt
(created_tmp_disk_tables / (created_tmp_disk_tables + created_tmp_tables)) * 100 
````
Ideally, this percentage should be less 25%. If you see that the percentage is 25% or greater, we suggest modifying two server parameters, *tmp_table_size* and *max_heap_table_size*. 

Below KQL summarizes the usage of temp files that would illustarte a general idea how much of temp files being generated.

````kql
//////////////////////////////
//  MySQL temp table usage
/////////////////////////////
AzMyStatus_CL
| where Time_t >= ago(1h)
| where LogicalServerName_s =~ "{replace to your server name here}"
| where MetricName_s in (
    'CREATED_TMP_DISK_TABLES', 
    'CREATED_TMP_FILES', 
    'CREATED_TMP_TABLES')
| project Time_t, MetricName_s, MetricValue_s
| extend Created_tmp_disk_tables_tmp = iff(MetricName_s == 'CREATED_TMP_DISK_TABLES', toreal(MetricValue_s), 0.0), 
         Created_tmp_files_tmp = iff(MetricName_s == 'CREATED_TMP_FILES', toreal(MetricValue_s), 0.0),
         Created_tmp_tables_tmp = iff(MetricName_s == 'CREATED_TMP_TABLES', toreal(MetricValue_s), 0.0)
| summarize Created_tmp_disk_tables = max(Created_tmp_disk_tables_tmp),
            Created_tmp_files = max(Created_tmp_files_tmp),
            Created_tmp_tables = max(Created_tmp_tables_tmp) by Time_t
| order by Time_t asc
| render timechart 
````



### Understand the usage of buffer pool
Normally, writes to the InnoDB Buffer Pool happen in the background. However, if it is necessary to read or create a page and no clean pages are available, it is also necessary to wait for pages to be flushed first. The *Innodb_buffer_pool_wait_free* counter counts how many times this has happened. *Innodb_buffer_pool_wait_free* greater than 0 is a strong indicator that the InnoDB Buffer Pool is too small.

- *Innodb_buffer_pool_read_requests* indicates the the number of logical read requests (read from memory) InnoDB has done.
- *Innodb_buffer_pool_reads* indicates the number of logical reads that InnoDB could not satisfy from the buffer pool, and had to read directly from the disk (physical reads).

The InnoDB Buffer Pool hit ratio is a indicator how often your pages are retrieved from memory instead of disk.

Below KQL summarizes the count of buffer pool read (physical and logical) that would generate historical data for you to understand the usage of buffer pool. The metrics would be critical for CPU usage analysis as a high logical read would contribute to high CPU usage. Users can consider tuning some queries to reduce the logical read count. In most cases, those high logical read queries are the ones that are not using indexes properly. 
````kql
//////////////////////////////
//  MySQL buffer pool usage
/////////////////////////////
AzMyStatus_CL
| where Time_t >= ago(1h)
| where LogicalServerName_s =~ "{replace to your server name here}"
| where MetricName_s in (
    'INNODB_BUFFER_POOL_READ_REQUESTS', 
    'INNODB_BUFFER_POOL_READS', 
    'INNODB_BUFFER_POOL_WRITE_REQUESTS', 
    'INNODB_BUFFER_POOL_PAGES_DIRTY', 
    'INNODB_BUFFER_POOL_WAIT_FREE')
| project Time_t, MetricName_s, MetricValue_s
| extend Innodb_buffer_pool_read_requests_tmp = iff(MetricName_s == 'INNODB_BUFFER_POOL_READ_REQUESTS', toreal(MetricValue_s), 0.0), 
         Innodb_buffer_pool_reads_tmp = iff(MetricName_s == 'INNODB_BUFFER_POOL_READS', toreal(MetricValue_s), 0.0),
         Innodb_buffer_pool_write_requests_tmp = iff(MetricName_s == 'INNODB_BUFFER_POOL_WRITE_REQUESTS', toreal(MetricValue_s), 0.0),
         Innodb_buffer_pool_pages_dirty_tmp = iff(MetricName_s == 'INNODB_BUFFER_POOL_PAGES_DIRTY', toreal(MetricValue_s), 0.0),
         Innodb_buffer_pool_wait_free_tmp = iff(MetricName_s == 'INNODB_BUFFER_POOL_WAIT_FREE', toreal(MetricValue_s), 0.0)
| summarize Innodb_buffer_pool_read_requests = max(Innodb_buffer_pool_read_requests_tmp), 
            Innodb_buffer_pool_reads = max(Innodb_buffer_pool_reads_tmp),
            Innodb_buffer_pool_write_requests = max(Innodb_buffer_pool_write_requests_tmp),
            Innodb_buffer_pool_pages_dirty = max(Innodb_buffer_pool_pages_dirty_tmp),
            Innodb_buffer_pool_wait_free = max(Innodb_buffer_pool_wait_free_tmp) by Time_t
| extend Innodb_buffer_pool_reads_cache_hit_percentage = round((Innodb_buffer_pool_read_requests-Innodb_buffer_pool_reads)*100/Innodb_buffer_pool_read_requests,3)
| order by Time_t asc
| render timechart 
````